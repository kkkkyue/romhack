M68000指令-备忘补充(整理zengfr).txt

资料收集:https://github.com/zengfr/romhack
----------------------------------------------------------------------------------------------
M68000

状态寄存器
68000比较、算术和逻辑操作会在状态寄存器SR的低端字节（又称CCR）中设置一些标志位，以供之后的条件跳转使用。这些标志位是：得零（Z）、进位（C）、溢出（V）、扩展（X）、负数（N）。尽管许多时候值是相同的，X与C依然是两个不同的标志位。这就允许算术、逻辑和移位操作的多余位与逻辑控制/连接造成的进位区别开。
----------------------------------------------------------------------------------------------

指令后缀
大部分指令都有表示操作长度的后缀：.B、.W或.L，分别表示这一操作在字节（8比特）上、字（16比特）上或长字（32比特）上进行。运算的过程和结果都会受到后缀的影响。在运算过程中，只有属于操作长度范围的部分才会参与运算。比方说，执行MOVE.B D2,D1会把D1的最低一字节复制到D2的最低一字节处，而两者的其余字节均不受影响。对于CCR，各标志位的值会由操作长度的最高有效位决定。如果某次ADD.B使得结果的第7Bit位为1，则CCR的N位会置1；如果某次ADD.L使得结果的第7Bit位为1，并且第15Bit不为1，则CCR的N位不会置1。在后一种情况下，CCR的N位只受第15Bit，即一个字的最高有效位影响。另一个例子是在自增/自减寻址中，自增/自减的长度因操作后缀而异。如果操作为MOVE.B，则自增/自减1；W为2；L为4。

----------------------------------------------------------------------------------------------
大部分68000的指令都是二元的。目的操作数在前，源操作数在后。

移动指令
MOVE：标准移动指令。另有一些其它移动指令供选择：MOVEA（移动到地址寄存器An，不会影响CCR，但后缀不可为.B）、MOVEQ（移动一个8位数到目标寄存器，因为可将数值直接写入指令故称快速移动）、MOVEM（移动寄存器组到指定堆栈，多用于中断/子程序处理的第一步）等。
LEA：移动一个地址值到目标寄存器。LEA $2000,A0表示将A0的值设为16进制的2000。应注意此时不加立即数标志#。
LINK/ULNK：建立/取消堆栈帧。这个指令用于翻译高级语言的函数调用。LINK An, #-x可将An作为函数栈指针，并SP所指向的用户栈内取得x大小的空间存储局部变量，之后SP仍将指向栈顶，而An指向栈顶+x的位置。x的值在编译时由编译器自动算出。
算数指令：ADD（加）、SUB（减）、MULU /MULS（无/有符号乘）、DIVU/DIVS（无/有符号除）、NEG （取补）、及CMP（类似于减但只会影响标志位而不改变操作数）。算数指令也多成组提供。对于ADD，还有ADDA（加地址，不会影响标志位）、ADDI（加立即数）、ADDQ（快速加，加数不大于8以便于直接放在操作码中，比x86的INC指令书写麻烦但功能更强）、ADDX（影响进位符，用于大数运算）等。
BCD码算数指令：ABCD（加）和SBCD（减）。
移位指令
逻辑移位（移位后用0补充）：LSL（左移）、LSR（右移）
算数移位（移位后用原来最高/最低有效位补充）：ASL（左移）、ASR（右移）
循环移位（移位后用所移动位补充）：ROL（左移）、ROR（右移）
循环扩展移位（移位至CCR的X位，同时用之前的X位补充）：ROXL（左移）、ROXR（右移）
位操作指令：BSET（置1）、BCLR （清0）和BTST （如果测试位在改变前为0则将CCR的Z设为1）。
多任务处理：TAS（测试并置位）。这个指令用于实现信号灯等同步机制。
流程控制：JMP（无责任跳转）、 JSR （跳转至子例程）、BSR （按相对地址跳转至子例程，多用于跳转至用户定义例程）、RTS （从子例程返回）、RTE （从异常/中断中返回）、 TRAP（自陷，即软中断）、CHK（检查地址是否越界，如是则触发异常）。
JMP指令只是纯粹跳转，不会将下一条指令地址压栈；JSR和BSR会将下一条指令压栈。
RTS将栈指针指向内容弹出给PC。
条件测试并跳转：Bcc系列指令。cc定义了所测试的条件位。常用的如：
BNE：不等于时跳转。
BEQ：等于时跳转。
BRA：无条件跳转。
----------------------------------------------------------------------------------------------
补充:
1、JMP、BRA指令只是纯粹跳转，不会将下一条指令地址压栈；JSR和BSR会将下一条指令压栈.
2、状态寄存器SR：（右到左）CVZNX、（右到左）XNZVC 
3、字节位 左高 右低

条件位：
C： 进位标志位     V： 溢出标志位
Z： 结果为零标志位  N： 结果为负标志位

I0 – I2：三位中断屏蔽位，它建立CPU的中断优先级，值由0到7，只接受优先级高于值的那些中断。
S：CPU状态标志位，为1处于管态，为0处于目态
T：陷阱（Trap）中断指示位为1，
   在下一条指令执行后引起自陷中断 
-------------------------------------------------------------------------------------------------
以上为68000
-------------------------------------------------------------------------------------------------
（M68000好像一样没区别，参考) 

ARM 条件码 分支指令 比较指令 程序状态寄存器（CPSR）

条件码标志
  N、Z、C、V均为条件码标志位。它们的内容可被算术或逻辑运算的结果所改变, 并且可以决定某条指令是否被执行。条件码标志各位的具体含义如下表所示:
    N——本位设置成当前指令运算结果的bit[31]的值。当两个表示的有符号整数运算时, n=1表示运算结果为负数, n=0表示结果为正书或零。
    Z——Z=1表示运算的结果为零；Z=0表示运算的结果不为零。对于CMP指令, Z=1表示进行比较的两个数大小相等。
    V——对于加减运算指令, 当操作数和运算结果为二进制的补码表示的带符号数时, V=1表示符号为溢出；通常其他指令不影响V位。
    C——下面分四种情况讨论C的设置方法:
      在加法指令中（包括比较指令CMN）, 当结果产生了进位,则C=1,表示无符号运算发生上溢出；其他情况C=0。
      在减法指令中（包括比较指令CMP）, 当运算中发生借位, 则C=0, 表示无符号运算数发生下溢出；其他情况下C=1。
      对于包含移位操作的非加减运算指令, C中包含最后一次溢出的的位的数值,
      对于其他非加减运算指令, C位的值通常不受影响
	  
ARM 指令的条件码 
  条件码 助记符后缀   标 志                 含 义
 NV            忽略
 AL            忽略                  无条件执行
 EQ            Z置位                 相等
 NE            Z清零                 不相等
 MI            N置位                 负数
 PL            N清零                 正数或零
 VS            V置位                 溢出
 VC            V清零                 未溢出
 LS            C清零Z置位            无符号数小于或等于
 HI            C置位Z清零            无符号数大于
 CS            C置位                 无符号数大于或等于
 HS            C置位                 无符号数大于或等于
 CC            C清零                 无符号数小于
 LO            C清零                 无符号数小于
 GE            N等于V                带符号数大于或等于
 LT            N不等于V              带符号数小于
 GT            Z清零且（N等于V）     带符号数大于
 LE            Z置位或（N不等于V）   带符号数小于或等于
 
比较指令通常用于把一个寄存器与一个32位的值进行比较或测试.
比较指令根据结果更新cpsr的标志位,但不影响参与比较的寄存器内容.
在设置标志位后,其他指令可通过条件执行来改变程序的执行流程.
对于比较指令,不需要使用S后缀就可以改变标志位.
//--------------------------------------------------------------------------------------
//ARM 关于C、V值更多的解释
//---------------------------------------------------------------------------------------

  处理器对两个操作数进行运算时,
  按照无符号数求得结果, 并相应设置进位标志C；
  同时, 根据是否超出有符号数的范围设置溢出标志V。
  如果将参加运算的操作数认为是无符号数, 就应该关心进位；
  如果将参加运算的操作数认为是有符号数, 则要注意是否溢出。

  溢出标志V和进位标志C是两个意义不同的标志。

    进位标志C表示无符号数运算结果是否超出范围 -- 运算结果仍然正确(部分)
    溢出标志V表示有符号数运算结果是否超出范围 -- 运算结果已经不正确

      处理器内部以补码表示有符号数,
      8个二制位能够表达的整数范围是: +127 ~ -128,
      16位表达的范围是: +32767 ~ -128。
      如果运算结果超出了这个范围, 就是产生了溢出,
      有溢出, 说明有符号数的运算结果需要考虑溢出情况。

      判断运算结果是否溢出有一个简单的规则:
两个正数相加得到负数,就是溢出了. (或一个正数减一个负数)
两个负数相加得到正数,就是溢出了.
一个正数和一个负数相加不可能溢出
      当两个相同符号数相加，而运算结果的符号与原数据符号相反时，产生溢出
----------------------------------------------------------------------------------------------
以下应该为x86汇编 参考别混淆
汇编指令 - 状态寄存器、cmp、test、jz等指令

 三、 直接标志转移
指令格式                 机器码                    测试条件                       如...则转移  
JC                           72                           C=1                               有进位
JNC                         73                          C=0                               无进位
JZ/JE                       74                          Z=1                                零/  
JNZ/JNE                  75                         Z=0                               不为零/  
JS                           78                           S=1                                负号
JNS                         79                          S=0                                正号
JO                           70                          O=1                               有溢出
JNO                         71                         O=0                               无溢出
JP/JPE                     7A                        P=1                               奇偶位为偶
JNP/IPO                   7B                        P=0                               奇偶位为奇

四、间接标志转移
先用cmp指令比较再用下面的判断（少了一个 JE 为等于）：
指令格式          机器码             测试格式                如...则转移
JA/JNBE()        77                    CZ=0                      >/  
JAE/JNB()        73                    C=0                        >=/  
JB/JNAE()        72                    C=1                        </  
JBE/JNA()        76                    CZ=1                      <=/  
JG/JNLE()        7F                   (SO)Z=0                  >/  
JGE/JNL()        7D                   SO=0                      >=/  
JL/JNGE()        7C                   SO=1                      </  
JLE/JNG()        7E                   (SO)Z=1                  <=/
 